// This is a personal academic project. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com
/*1. Отступ от левого поля указывает на уровень вложенности.
2. Циклы while, for, repeat и условные конструкции имеют тот же смысл, что и в pascal-е.
3. Символ “--” обозначает комментарий
4. Символ “:=” обозначает присваивание
5. Переменные локальны в рамках процедуры, если не оговорено иначе
6. Индекс массива пишется в квадратных скобках, конструкция A[i] означает i элемент в массиве A
7. Возможно использование объектов, состоящих из нескольких полей, или имеющих несколько атрибутов, значения поля записывается как ИмяПоля[ИмяОбъекта].
К примеру, длина массива A записывается как Length[A]; что означают квадратные скобки - выясняется по контексту (переменная, обозначающая массив, или объект является указателем на составляющие его данные). После присвоения y:=x для любого поля f будет выполняться равенство f[y]=f[x]; определение того, что является атрибутом – функция, переменная или что-либо еще, - делается по контексту.
8. Указатель может иметь специальное значение NIL, не указывающее ни на какой объект.
9. Параметры передаются по значению: вызванная процедура получает собственную копию параметров, изменения параметров внутри процедуры снаружи не видно. При передаче объектов копируется указатель на данные, соответствующие этому объекту.



Задача

Функция сортирующая массив элементов A:
Sort(A,p,r)
1 if p < r
2    then           q := round_half_down((p+r)/2)
3                       Sort(A,p,q)
4                       Sort(A,q+1,r)
5                       Merge(A,p,q,r)

Пример массива:
A = (5,2,4,6,1,3,2,6)

Примера запуска:
Sort(A,1,length[A])


Необходимо:
Разработать алгоритм функции Merge(A,p,q,r) на любом удобном вам языке, с использованием дополнительной памяти или без нее, как вам будет быстрее или удобнее в реализации.
Если у вас получится - с радостью ждем вас для прохождения дополнительного тестирования.
 */

#include <iostream>
#include <vector>
#include <cmath>

void merge(std::vector<int>& A, int p, int q, int r);
void Sort(std::vector<int>& A, int p, int r);

int main()
{
   std::vector <int> A {5, 2, 4, 6, 1, 3, 2, 6};

   for (size_t i = 0; i < A.size(); ++i)
   {
    std::cout << A[i] << ' ';
   }
   std::cout << std::endl;

   Sort(A, 0, A.size() - 1);

   for (size_t i = 0; i < A.size(); ++i)
   {
      std::cout << A[i] << ' ';
   }
   std::cout << std::endl;

   return 0;
}

void Sort(std::vector<int>& A, int p, int r)
{
    if (p >= r)
    {
        return;
    }

    int q = floor((p + r) / 2);

    Sort(A, p, q);
    Sort(A, q + 1, r);

    merge(A, p, q, r);
}

void merge(std::vector<int>& A, int p, int q, int r)
{
    int nl = q - p + 1;
    int nr = r - q;

    int left[nl];
    int right[nr];

    for (int i = 0; i < nl; ++i)
    {
        left[i] = A[p + i];
    }
    for (int j = 0; j < nr; ++j)
    {
        right[j] = A[q + j + 1];
    }

    int i = 0;
    int j = 0;
    int k = p;

    while (i < nl && j < nr)
    {
        if (left[i] <= right[j])
        {
            A[k] = left[i];
            i++;
        }
        else
        {
            A[k] = right[j];
            j++;
        }
        k++;
    }

    while (i < nl)
    {
        A[k] = left[i];
        i++;
        k++;
    }

    while (j < nr)
    {
        A[k] = right[j];
        j++;
        k++;
    }
}